---
layout: post
math: true
title: "Introduction to Machine Learning"
categories: [AI, Machine Learning]
tags: [Machine Learning]
---

## 一、基本概念

### 什么是机器学习

总的来说，机器学习就是大数据时代背景下**处理数据的各种方法**的总称。机器学习利用各种数理模型对数据进行建模，对数据进行预测和分析，在实际应用中指导决策。

我们通常将用于学习的数据对象或者实例称为**样例或者样本**，每个样例x采用一个向量 $x=(x^{(1)},x^{(2)},\cdots,x^{(n)})^T$来表示.

- 向量的每个分量对应样例的一个**特征或者属性.**
- n为样例$x$的特征个数，也称为**维数，**$x^{(i)}$为样例x的第i 维属性的属性值.
- 属性张成的空间$\chi$为**特征空间，也称为样本空间或输入空间**，记作$\chi$.

$$
x=(x^{(1)},x^{(2)},\cdots,x^{(n)})^T\in\mathcal{X}
$$

一般而言，数据对象的特征和学习任务相关，如果有不相关的特征可能会影响模型的预测能力。

### 机器学习的分类

机器学习一般包括监督学习、无监督学习、半监督学习、强化学习等。

#### 监督学习

监督学习 (Supervised learning)基于给定的**标记数据集**$T=\{(x_i,y_i)\}_{i=1}^N$学习从输入空间$\chi$ 到输出空间$\gamma$ 的映射 (模型)，并利用该映射对未见 (unseen) 实例x对应的输出y进行预测。监督学习有两个核心问题：

- **分类(classification)问题**：输出空间$\gamma$是一个离散值的集合(通常也是有限的).

  - $\mathcal{Y}=\{c_1,c_2,\cdots,c_M\}$, 其中$M$为类别的个数.
  - 二分类(binary classification)问题：$M=2.$

    - $\mathcal{Y}=\{+1,-1\}.$
    - $\mathcal{Y}=\{0,1\}.$

  - 多分类(multi-class classification) 问题：$M>2.$

- **回归 (regression) 问题**：输出空间$\gamma=\mathbb{R}.$

#### 无监督学习

无监督学习( Unsupervised learning) 基于给定的**无标记的数据集**$T=\{x_i\}_{i=1}^N$，发现数据中隐含的知识或者模式(interesting patterns)，并将学得的模式应用于未见实例。

- 无监督学习通常也被称为知识发现(knowledge discovery)；
- 通常没有明确的知识模式类型、衡量学习结果等的度量，依赖于具体学习场景和应用领域；
- 更具有主观性和挑战性.

一个典型的无监督学习任务——**聚类**，聚类的目的是将无标记的数据集$T=\{x_i\}_{i=1}^N$划分成若干子集。

- 这些子集通常互不相交，称每个子集为簇 N，每个簇对应于一个潜在的概念；
- 属于同一子集的样本数据尽**可能相互相似**；
- 不同子集的样本尽可能不同

#### 半监督学习和强化学习

![截屏2023-12-20 12.22.59](https://aurora-pics.oss-cn-beijing.aliyuncs.com/Pic/202407241358100.png)

## 二、模型选择

### 机器学习三要素

机器学习方法都是由模型、策略和算法构成的，即机器学习方法由三要素构成，可以简单地表示为：

> 机器学习方法＝**模型＋策略＋算法**

- **模型：**在监督学习过程中，模型就是所要学习的**条件概率分布或决策函数**。模型的假设空间包含所有可能的条件概率分布或决策函数；
- **策略：**有了模型的假设空间，机器学习接着需要考虑的是按照什么样的**准则**学习或选择最优的模型；
- **算法：**算法是指学习模型的具体计算方法；

### 学习策略

机器学习关心的问题是要学什么样的模型，在监督学习过程中，模型就是所要学习的条件概率分布或决策函数。模型的**假设空间(hypothesis space)**包含所有可能的条件概率分布或决策函数。例如，假设决策函数是输入变量的线性函数，那么模型的假设空间就是所有这些线性函数构成的函数集合，假设空间中的模型一般有无穷多个。那么怎么选出最好的模型呢，首先引入损失函数与风险函数的概念：

- **损失函数**度量模型一次预测的好坏；
- **风险函数**度量平均意义下模型预测的好坏。

在假设空间$\mathcal{F}$ 中选取模型 $f$ 作为决策函数，对于给定的输入 X,由 $f(X)$ 给出相应的输出$Y$,这个输出的预测值 $f(X)$ 与真实值$Y$ 可能一致也可能不一致，用一个**损失函数(loss function)或代价函数(cost function)**来度量预测错误的程度。损失函数是 $f(X)$ 和 Y 的非负实值函数，记作 $L(Y,f(X))$。机器学习常用的损失函数有以下几种：

1. **0-1 损失函数**(0-1 loss function)

   $$
   L(Y,f(X))=\begin{cases}&1,\quad Y\neq f(X)\\&0,\quad Y=f(X)\end{cases}
   $$

2. **平方损失函数**(quadratic loss function)

   $$
   L(Y,f(X))=(Y-f(X))^2
   $$

3. **对数损失函数**(logarithmic loss function)或对数似然损失函数(log-likelihood loss function)

$$
\begin{aligned}L(Y,P(Y|X))&=-\log P(Y|X)\end{aligned}
$$

损失函数值越小，模型就越好。由于模型的输入、输出 $(X,Y)$ 是随机变量，遵循联合分布$P(X,Y)$,所以损失函数的期望是:

$$
\begin{aligned}
R_{\mathrm{exp}}(f)& =E_{P}[L(Y,f(X))]  \\
&=\int_{\mathcal{X}\times\mathcal{Y}}L(y,f(x))P(x,y)\mathrm{d}x\mathrm{d}y.
\end{aligned}
$$

这是理论上模型 $f(X)$ 关于联合分布 $P(X,Y)$ 的平均意义下的损失，称为**风险函数 (risk function) 或期望损失(expected loss)。**由于联合分布$P(X,Y)$ 是不知道的，所以通常我们不会直接使用风险函数，而是用经验风险。给定一个训练数据集

$$
T=\left\{\left(x_1, y_1\right),\left(x_2, y_2\right), \cdots,\left(x_N, y_N\right)\right\}
$$

模型 $f(X)$ 关于训练数据集的平均损失称为**经验风险 (empirical risk)** , 记作 $R_{\text {emp }}$ :

$$
R_{\text {emp }}(f)=\frac{1}{N} \sum_{i=1}^N L\left(y_i, f\left(x_i\right)\right)
$$

- 期望风险 $R_{\exp }(f)$ 是模型关于联合分布的期望损失；
- 经验风险 $R_{\mathrm{emp}}(f)$ 是模型关于训练样本集的平均损失。

根据大数定律, **当样本容量 $N$ 趋于无穷时, 经验风险 $R_{\mathrm{emp}}(f)$ 趋于期望风险 $R_{\exp }(f)$** 。所以一个很自然的想法是用经验风险估计期望风险。但是, 由于现实中训练样本数目有限, 甚至很小, 所以用经验风险估计期望风险常常并不理想, 要对经验风险进行一定的矫正。这就关系到监督学习的两个基本策略: 经验风险最小化和结构风险最小化。

#### 经验风险最小化

在假设空间、损失函数以及训练数据集确定的情况下，经验风险函数式(1.14) 就可以确定。经验风险最小化 (empirical risk minimization, ERM) 的策略认为，经验风险最小的模型是最优的模型。根据这一策略，按照经验风险最小化求最优模型就是求解最优化问题：

$$
\min_{f\in\mathcal{F}}\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))
$$

其中$\mathcal{F}$ 是假设空间。当样本容量足够大时，经验风险最小化能保证有很好的学习效果，在现实中被广泛采用。比如，极大似然估计(maximum likelihood estimation) 就是经验风险最小化的一个例子。当模型是条件概率分布、损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计。但是，当样本容量很小时，经验风险最小化学习的效果就未必很好，会产生“**过拟合” (over-fitting)** 现象。

#### 结构风险最小化

**结构风险最小化 (structural risk minimization, SRM) 是为了防止过拟合而提出来的策略**。结构风险最小化等价于正则化(regularization)。结构风险在经验风险上加上表示模型复杂度的正则化项(regularizer)或罚项(penalty term)。在假设空间、损失函数以及训练数据集确定的情况下，结构风险的定义是

$$
R_{\mathrm{srm}}(f)=\frac1N\sum_{i=1}^NL(y_i,f(x_i))+\lambda J(f)
$$

- 其中，$J(f)$ 为模型的复杂度，是定义在假设空间$\mathcal{F}$上的泛函；
- 模型 $f$ 越复杂，复杂度 $J(f)$ 就越大；反之，模型 $f$ 越简单，复杂度 $J(f)$ 就越小；
- $\lambda\geqslant0$ 是系数，用以权衡经验风险和模型复杂度；
- 结构风险小需要经验风险与模型复杂度同时小，结构风险小的模型往往对训练数据以及未知的测试数据都有较好的预测。

<img src="https://aurora-pics.oss-cn-beijing.aliyuncs.com/Pic/202407241358063.png" alt="截屏2023-12-20 16.09.55" style="zoom:67%;" />

上图给出了模型复杂度与训练误差和测试误差的关系：

1. 模型复杂度小，训练误差较大，被称为**欠拟合**现象；
2. 模型复杂度过高，训练误差小，测试误差（泛化误差）大，被称为**过拟合现象**。

比如，贝叶斯估计中的最大后验概率估计(maximum posterior probability estimation, MAP) 就是结构风险最小化的一个例子。当模型是条件概率分布、损失函数是对数损失函数、模型复杂度由模型的先验概率表示时，结构风险最小化就等价于最大后验概率估计。

结构风险最小化的策略认为结构风险最小的模型是最优的模型，所以求最优模型就是求解最优化问题：

$$
\min_{f\in\mathcal{F}}\frac1N\sum_{i=1}^NL(y_i,f(x_i))+\lambda J(f).
$$

### 训练误差与泛化误差

- 训练误差：模型在训练集上的**经验风险**，记为：$\hat{R}(f)=\frac1N\sum_{i=1}^NL(y_i,f(x_i))$；
- 泛化误差：学习的模型在对未知数据的预测能力，也就是**期望风险**，记为$R(f)=E[L(Y,f(X))]$；

通过经验风险最小化，选出的模型记为：

$$
f_N = \arg \min_{f\in\mathcal{F}} \hat{R}(f).
$$

$f_N$ 依赖训练数据集的样本容量 $N$。人们更关心的是 $f_N$ 的泛化能力

$$
R(f_{N})=E[L(Y,f_{N}(X))].
$$

下面讨论从有限集合$\mathcal{F}=\{f_1,f_2,\cdots,f_d\}$ 中任意选出的函数 $f$ 的**泛化误差上界**。

**定理 (泛化误差上界)**

> 对二类分类问题，当假设空间是有限个函数的集合 $\mathcal{F}=$
>
> $\{f_1,f_2,\cdots,f_d\}$ 时，对任意一个函数 $f\in\mathcal{F}$, 至少以概率 $1-\delta,0<\delta<1$, 以下不等式成立：
>
> $$
> R(f)\leqslant\hat{R}(f)+\varepsilon(d,N,\delta)
> $$
>
> 其中：
>
> $$
> \varepsilon(d,N,\delta) = \sqrt{\frac{1}{N}(\log d+\log\frac{1}{\delta})}.
> $$

从上述定理我们可以知道：

- $R(f)$ 是泛化误差，右端即为泛化误差上界；
- 在泛化误差上界中，第1 项是训练误差，训练误差越小，泛化误差也越小；
- 第2 项 $\varepsilon(d,N,\delta)$ **是 N 的单调递减函数， 当$N$ 趋于无穷时趋于 0**;
- 同时它也是 $\sqrt{\log d}$ 阶的函数**，假设空间 $\mathcal{F}$ 包含的函数越多，其值越大**;
- **训练误差$\hat{R}(f)$小并不能一定保证模型$f_N$的泛化性能好**。

泛化性能与学习算法捕获所有样本的共有知识模式的能力有关经验误差反映的是学习算法捕获训练数据蕴含的知识模式的能力。过小的训练误差可能导致所谓的过拟合 (Overfitting) 现象。

### 泛化误差的偏差-方差分解

我们知道随着模型复杂度的增加，学习算法的学习能力越来越强，训练误差越来越小。而泛化误差先是随着训练误差的缩小而减小，但随着模型复杂度的进一步增加泛化误差不降反升。

泛化误差与模型复杂度的关系为什么这样？ 针对回归任务，进一步讨论泛化误差由哪几个部分构成.
我们设$h_\mathrm{T}$是基于训练数据集$T$学习到的回归模型，对给定的$x$, 则学习算法的泛化误差为

$$
E_T[(h_T(x)-c(x))^2].
$$

其中，$c(x)$为真实标记。定义学习算法对数据$x$的**期望输出**为

$$
\bar{h}(x)=E_T[h_T(x)].
$$

$x$的期望输出与真实标记c$(x)$之间的差别称为**偏差**，即

$$
Bias(x)=E_T[(h_T(x)-c(x)]=\bar{h}(x)-c(x).
$$

- 偏差描述了学习算法对$x$的预测期望相对于x的真实输出的偏离程度；
- **偏差反映了学习算法的学习能力，偏差越小，说明学习算法的学习能力越强**.

基于相同样本容量的不同训练数据集产生的**预测方差**为

$$
Var(x)=E_T[(h_T(x)-\bar{h}(x))^2].
$$

- 方差刻画学习算法使用相同容量的不同训练数据集所导致的学习性能的变动情况；
- **方差越小，说明学习算法对数据扰动的容忍能力越强**.

接下来，我们对泛化误差进行如下分解：

$$
\begin{aligned}
E_T[(h_T(x)-c(x))^2] &=E_T[h_T^2(x)-2h_T(x)c(x)+c^2(x)] \\
&=E_T[h_T^2(x)]-2E_T[h_T(x)]c(x)+c^2(x) \\
&= E_T[h_T^2(x)]-2\bar{h}(x)c(x)+c^2(x)  \\
&=E_T[h_T^2(x)]-\bar{h}^2(x)+\bar{h}^2(x)-2\bar{h}(x)c(x)+c^2(x) \\
&=E_T[(h_T(x)-\bar{h}(x))^2]+(\bar{h}(x)-c(x))^2 \\
&=-Var(x)+Bias^2(x). \\
\end{aligned}
$$

这说明泛化误差可分解为**方差和偏差**的平方之和。由于噪声等的存在，使得$x$对应的观测$y$未必一定有

$$
y=c(x).
$$

我们不妨设

$$
y=c(x)+\varepsilon,
$$

其中$\varepsilon$为噪声，假定$\varepsilon$服从分布$\varepsilon$且其期望为0，即$E[\varepsilon]=0$.那么可以得到：

$$
E_{T\sim D|T|,\varepsilon\sim\mathcal{E}}[(h_T(x)-y)^2]=Var(x)+Bias^2(x)+E[\varepsilon^2],
$$

即泛化误差可以**分解为方差、偏差和噪声三部分**，其中噪声部分也称为不可约误差，反映了学习问题本身的难度.

![截屏2023-12-20 16.36.21](https://aurora-pics.oss-cn-beijing.aliyuncs.com/Pic/202407241358130.png)

方差和偏差通常是相互抵触的:

- 当模型复杂度过于简单时，拟合能力比较弱，**对数据扰动不敏感**,此时偏差在泛化误差中起主导作用；
- 随着模型复杂度的提高，算法的拟合能力不断增强，偏差逐渐减少。但学习能力的提高也带来过拟合的风险，使得学习算法**对数据扰动逐渐敏感**，方差在泛化误差中的比重逐渐增大，最终导致泛化误差不断增大。

### 正则化

正则化一般具有如下形式:

$$
\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^N L\left(y_i, f\left(x_i\right)\right)+\lambda \Omega(f)
$$

其中:

1. 第 1 项是经验风险；
2. 第 2 项是正则化项, $\lambda \geqslant 0$ 为正则化参数；

正则化项可以取不同的形式。例如, 在回归问题中, 正则化项可以是参数向量的 $L_2$ 范数:

$$
L(w)=\frac{1}{N} \sum_{i=1}^N\left(f\left(x_i ; w\right)-y_i\right)^2+\frac{\lambda}{2}\|w\|^2
$$

这里, $\|w\|$ 表示参数向量 $w$ 的 $L_2$ 范数。正则化项也可以是参数向量的 $L_1$ 范数:

$$
L(w)=\frac{1}{N} \sum_{i=1}^N\left(f\left(x_i ; w\right)-y_i\right)^2+\lambda\|w\|_1
$$

这里, $\|w\|_1$ 表示参数向量 $w$ 的 $L_1$ 范数。

![截屏2023-09-14 10.39.28](https://aurora-pics.oss-cn-beijing.aliyuncs.com/Pic/202309141039222.png)

### 交叉验证

如果给定的样本数据充足，进行模型选择的一种简单方法是随机地将数据集切分成三部分，分别为训练集（training set）、验证集（validation set）和测试集（test set）。训练集用来训练模型，验证集用于模型的选择，而测试集用于最终对学习方法的评估。

但是，在许多实际应用中数据是不充足的。为了选择好的模型，可以采用交叉验证方法。交叉验证的基本想法是重复地使用数据，把给定的数据进行切分，将切分的数据集组合为训练集与测试集，在此基础上反复地进行训练、测试以及模型选择。

**1 简单交叉验证(留出法）**

> 简单交叉验证方法是：
>
> 1. 首先随机地将已给数据分为两部分，一部分作为训练集，另一部分作为测试集（例如，70％的数据为训练集，30％的数据为测试集）；
> 2. 然后用训练集在各种条件下（例如，不同的参数个数）训练模型，从而得到不同的模型；
> 3. 在测试集上评价各个模型的测试误差，选出测试误差最小的模型。

![截屏2023-12-20 17.43.46](https://aurora-pics.oss-cn-beijing.aliyuncs.com/Pic/202312201744491.png)

**2 _K_ 折交叉验证**

> 应用最多的是 _K_ 折交叉验证（_K_-fold cross validation），方法如下：
>
> 1. 首先将数据集$D$随机划分为$k$个互不相交、大小相似的子集$D_1,D_2,\cdots,D_k.$
> 2. 然进行$k$次训练-测试过程，其中第$i$次训练-学习过程中以$D-D_i$为训练数据集学得模型$h_{D-D_i}$
> 3. 以$D_i$为测试集对$h_{D-D_i}$进行测试评估，得到测试误差$\hat{R}_{test}(h_{D-D_i}).$
> 4. 以
>
>    $$
>    \frac1k\sum_{i=1}^k\hat{R}_{test}(h_{D-D_i})
>    $$
>
>    作为$h_D$在本次数据集随机划分下的测试评估结果。
>
> 5. 将这一过程对可能的 _K_ 种选择重复进行；最后选出 _K_ 次评测中平均测试误差最小的模型。
>
> 比较耗时，每轮要训练K次。

**3 留一交叉验证**

> _K_ 折交叉验证的特殊情形是 _K_ = _N_，称为留一交叉验证（leave-one-out cross validation），往往在数据缺乏的情况下使用。这里，_N_ 是给定数据集的容量。设数据集为$D$，其误差为：
>
> $$
> \hat{R}(f_D)=\frac1{|D|}\sum_{x\in D}L(f_{D-\{x\}}(x),y).
> $$
>
> - 也就是说每次测试集只有一个数据
> - 训练N次，数据量大时，计算开销大

### 自助法

自助法是为了解决交叉验证法在模型选择阶段**训练集规模比整个样本小**的问题，采用**有放回抽样**对交叉验证法进行改造。其具体策略如下：

1. 先从 $D$ 中以有放回的抽样方式随机抽取 $|D|$ 个数据来构建训 练数据集 $T$,
2. 然后以 $D$ 中没有被抽中的数据构建测试数据集 $T^{\prime}$.

![截屏2023-09-16 12.28.29](https://aurora-pics.oss-cn-beijing.aliyuncs.com/Pic/202309161228538.png)

- 自助法解决了交叉验证法中模型选择阶段和最终模型训练阶段的训练集规模差异问题.

## 三、模型评估

### 回归评价指标

#### 1 MSE

回归问题最常用的评价指标是均方误差（Mean Square Error,MSE），其计算公式为：

$$
MSE(y,\hat y)=\frac{1}{n}\sum_{i=1}^{n}(y_i-\hat y_i)^2
$$

#### 2 RMSE

均方根误差（Root Mean Square Error,RMSE）：

$$
RMSE(y,\hat y)=\sqrt{MSE(y,\hat y)}=\sqrt{\frac{1}{n}\sum_{i=1}^{n}(y_i-\hat y_i)^2}
$$

均方误差和均方根误差通常会放大离群值对模型评估结果的影响，一种克服这个问题的方法是用，平均绝对误差（Mean Absolute Error,MAE)

#### 3 MAE

平均绝对误差（Mean Absolute Error,MAE):

$$
MAE(y,\hat y)=\frac{1}{n}\sum_{i=1}^{n}|y_i-\hat y_i|
$$

### 分类评价指标

在二分类问题中，每一个样本可以划分为以下四种类型：

1. 真正(True Positive , TP)：被模型预测为正的正样本。
2. 真负(True Negative , TN)：被模型预测为负的负样本。
3. 假正(False Positive , FP)：被模型预测为正的负样本。
4. 假负(False Negative , FN)：被模型预测为负的正样本。

根据样本的真实标签和预测标签，可以得到一个混淆矩阵：

<img src="https://aurora-pics.oss-cn-beijing.aliyuncs.com/Pic/202312201756154.png" alt="截屏2022-05-18 下午9.11.58" style="zoom:67%;" />

正负样本选择，没有明确规定，根据应用场景进行选择，在机器学习中，往往将**少数样本**定义为正样本，表示希望**模型在训练时更加关注少数样本**。

#### 1 正确率

分类问题中最常见的指标是正确率(accuracy)，表示**模型预测正确的样本比例**，给定混淆矩阵时，正确率计算公式如下：

$$
正确率=\frac{TP+TN}{TP+TN+FP+FN}
$$

在**类别不均衡**时，正确率不是一个很好的度量模型好坏的指标。

> 比如，在文本情绪分类数据集中，有80%为正向的内容，20%为负向的内容，假如这个模型将所有样本都判断为正向，则正确率有80%!但是显然这个模型并不好

对于类别不均衡的数据集，精度和召回率是比正确率更好的性能评价指标

#### 2 精度

**精度(precision)**指正确预测的正样本占所有预测为正样本的比例：

$$
精度=\frac{TP}{TP+FP}
$$

#### 3 召回率

召回率（recall)又称为灵敏度或命中率，是指正样本中被正确预测的比例：

$$
召回率=\frac{TP}{TP+FN}
$$

通常精度和召回率是负相关的，实际应用中高精度往往对应低召回率，反之亦然，我们需要根据实际问题场景来选择哪一个指标。

#### 4 F值

单独考虑精度和召回率是片面的，需要综合考虑二者，在二分类问题中，可以定义一个综合考虑精度和召回率的指标，这个指标为F值：

$$
F=\frac{(1+\beta^2)精度\times 召回率}{\beta^2\times精度+召回率}
$$

其中$\beta$为正数，其作用是调节精度和召回率的权重，$\beta$越大，召回率的权重越大，$\beta$越小，精度的权重越大。当$\beta=1$时，它是精度和召回率的调和平均数：

## 参考资料

1. 李航 et al. 统计学习方法. 清华大学出版社, 2019.
